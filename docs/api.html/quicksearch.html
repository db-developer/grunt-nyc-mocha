<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: index.js /** * index.js: grunt-nyc-mocha * * @module grunt-nyc-mocha * *//* * © 2020, slashlib.org. * * index.js is distributed WITHOUT ANY WARRANTY; without even the implied * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Module initializer * @ignore */ const _m = { const: require( \"./constants\" ), tasks: require( \"./tasks\" ) } /** * Stringtable * @ignore */ const _STRINGS = { REGISTERMULTITASKNYCMOCHA: \"registerMultiTaskNYCMocha\" } /** * Registers the 'nyc_mocha' multitask. * * @param {grunt} grunt */ function registerMultiTaskNYCMocha( grunt ) { grunt.registerMultiTask( _m.const.TASKNAME_NYCMOCHA, _m.const.TASKDESCRIPTION_NYCMOCHA, /* istanbul ignore next */ function () { const task = this; const done = task.async(); _m.tasks.runTaskNYCMocha( grunt, task ) .then(( ) =&gt; { done(); }, ( error ) =&gt; { grunt.log.error( error ); done( false ); }); }); } /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.REGISTERMULTITASKNYCMOCHA, { value: registerMultiTaskNYCMocha, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"tasks_index.js.html":{"id":"tasks_index.js.html","title":"Source: tasks/index.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: tasks/index.js /** * index.js: grunt-nyc-mocha * * @module grunt-nyc-mocha * *//* * © 2020, slashlib.org. * * tasks/index.js is distributed WITHOUT ANY WARRANTY; without even the * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Module initializer * @ignore */ const _m = { nycmocha: require( \"./nycmocha\" ) }; /** * Stringtable * @ignore */ const _STRINGS = { RUNTASKNYCMOCHA: \"runTaskNYCMocha\" }; /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.RUNTASKNYCMOCHA, { value: _m.nycmocha.runTaskNYCMocha, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"constants.js.html":{"id":"constants.js.html","title":"Source: constants.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: constants.js /** * constants.js: grunt-nyc-mocha * * @module grunt-nyc-mocha/constants * *//* * © 2020, db-developer. * * constants.js is distributed WITHOUT ANY WARRANTY; without even the * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. */ \"use strict\"; /** * Stringtable * @ignore */ const _STRINGS = { PROPERTY_TASKNAME_NYCMOCHA: \"TASKNAME_NYCMOCHA\", PROPERTY_TASKDESC_NYCMOCHA: \"TASKDESCRIPTION_NYCMOCHA\", TASKNAME_NYCMOCHA: \"nyc_mocha\", TASKDESCRIPTION_NYCMOCHA: \"Generate coverage reports with nyc from mocha testruns\" }; /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.PROPERTY_TASKNAME_NYCMOCHA, { value: _STRINGS.TASKNAME_NYCMOCHA, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.PROPERTY_TASKDESC_NYCMOCHA, { value: _STRINGS.TASKDESCRIPTION_NYCMOCHA, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"lib.js.html":{"id":"lib.js.html","title":"Source: lib.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: lib.js /** * lib.js: grunt-nyc-mocha * * @module grunt-nyc-mocha/lib * *//* * lib.js: grunt-nyc-mocha * * © 2020, slashlib.org. * * lib.js is distributed WITHOUT ANY WARRANTY; without even the implied * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Stringtable * @ignore */ const _STRINGS = { ERROR_PEER_DEPENDENCY_MOCHA: \"Mocha peer dependency missing. Please \\\"npm install mocha\\\"\", ERROR_PEER_DEPENDENCY_NYC: \"NYC peer dependency missing. Please \\\"npm install nyc\\\"\", GETMOCHAPATH: \"getMochaPath\", GETNYCPATH: \"getNYCPath\", ISARRAY: \"isArray\", MSG_SKIPPING_ARRAY: \"Skipping empty &lt;name&gt; array\", MSG_ARRAY_EXPECTED: \"&lt;name&gt; must be an array of strings\", PATH_BIN_MOCHA: \"mocha/bin/_mocha\", PATH_BIN_NYC: \"nyc/bin/nyc\", TAG_NAME: \"&lt;name&gt;\" }; /** * Returns the path to the mocha executable/startscript * * @param {grunt} grunt * @return {string} path to mocha */ function getMochaPath( grunt ) { try { return require.resolve( _STRINGS.PATH_BIN_MOCHA ); } catch( error ) { /* istanbul ignore next */ grunt.fail.fatal( _STRINGS.ERROR_PEER_DEPENDENCY_MOCHA ); } } /** * Returns the path to the nyc executable/startscript * * @param {grunt} grunt * @return {string} path to nyc */ function getNYCPath( grunt ) { try { return require.resolve( _STRINGS.PATH_BIN_NYC ); } catch( error ) { /* istanbul ignore next */ grunt.fail.fatal( _STRINGS.ERROR_PEER_DEPENDENCY_NYC ); } } /** * Checks if options is of type array and passes it to callback. * * @param {grunt} grunt * @param {Array} options * @param {string} name * @param {Function} callback */ function isArray( grunt, options, name, callback ) { if ( Array.isArray( options )) { if (( options.length ) &amp;&amp; ( callback )) { callback( options ); } else grunt.verbose.ok( _STRINGS.MSG_SKIPPING_ARRAY.replace( _STRINGS.TAG_NAME, name )); } else throw new Error( _STRINGS.MSG_ARRAY_EXPECTED.replace( _STRINGS.TAG_NAME, name )); } /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.GETMOCHAPATH, { value: getMochaPath, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.GETNYCPATH, { value: getNYCPath, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.ISARRAY, { value: isArray, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"options_index.js.html":{"id":"options_index.js.html","title":"Source: options/index.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: options/index.js /** * index.js: grunt-nyc-mocha/options * * @module grunt-nyc-mocha/options * *//* * © 2020, slashlib.org. * * options/index.js is distributed WITHOUT ANY WARRANTY; without even the * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Module initializer * @ignore */ const _m = { nycmocha: require( \"./nycmocha\" ) }; /** * Stringtable * @ignore */ const _STRINGS = { TONYCMOCHAARGS: \"toNYCMochaArgs\" }; /** * Returns an object wich holds an array of arguments, which will be used to * run the 'nyc_mocha' task and the array of options the arguments were created * from. * * @return {Promise&lt;Object&gt;} obj * @return {Array&lt;strings&gt;} obj.args an array of arguments * @return {Array&lt;any&gt;} obj.opts an array of options */ function toNYCMochaArgs( grunt, task ) { return _m.nycmocha.toArgs( grunt, task ); } /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.TONYCMOCHAARGS, { value: toNYCMochaArgs, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"options_nycmocha.js.html":{"id":"options_nycmocha.js.html","title":"Source: options/nycmocha.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: options/nycmocha.js /** * options/nycmocha.js: grunt-nyc-mocha * * @module grunt-nyc-mocha/options/nycmocha * *//* * © 2020, slashlib.org. * * options/nycmocha.js is distributed WITHOUT ANY WARRANTY; without even the * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Module initializer * @ignore */ const _m = { path: require( \"path\" ), lib: require( \"../lib\" ) }; /** * Stringtable * @ignore */ const _STRINGS = { ERROR_MSG_MISSING_GRUNT: \"nycmocha.js - Function 'toArgsImpl': missing parameter 'grunt'.\", ERROR_MSG_MISSING_OPTIONS: \"nycmocha.js - Function 'toArgsImpl': missing parameter 'options'.\", ERROR_MSG_MISSING_TASK_I: \"nycmocha.js - Function 'toArgs': missing parameter 'task'.\", ERROR_MSG_MISSING_TASK_II: \"nycmocha.js - Function 'toArgsImpl': missing parameter 'task'.\", FALSE: `${ false }`, GETOPTIONS: \"getOptions\", GETTASKOPTIONS: \"getTaskOptions\", OPTIONS_BAILOUT: \"--bail\", OPTIONS_BRANCHES: \"--branches\", OPTIONS_CHECK_COVERAGE: \"--check-coverage\", OPTIONS_CLEAN: \"--clean\", OPTIONS_COLOR: \"--color\", OPTIONS_CWD: \"--cwd\", OPTIONS_EXCLUDE: \"--exclude\", OPTIONS_EXIT: \"--exit\", OPTIONS_EXTENSION: \"--extension\", OPTIONS_FUNCTIONS: \"--functions\", OPTIONS_INCLUDE: \"--include\", OPTIONS_LINES: \"--lines\", OPTIONS_MOCHA_OPTS: \"options.mocha.opts\", OPTIONS_NODE_OPTIONS: \"options.node.options\", OPTIONS_NYC_COVERAGE_REPORTER: \"options.nyc.coverage.reporter\", OPTIONS_NYC_EXCLUDES: \"options.nyc.excludes\", OPTIONS_NYC_EXTENSIONS: \"options.nyc.extensions\", OPTIONS_NYC_INCLUDES: \"options.nyc.includes\", OPTIONS_NYC_OPTS: \"options.nyc.opts\", OPTIONS_PER_FILE: \"--per-file\", OPTIONS_PRODUCE_SOURCEMAP: \"--produce-source-map\", OPTIONS_SOURCEMAP: \"--source-map\", OPTIONS_STATEMENTS: \"--statements\", OPTIONS_RECURSIVE: \"--recursive\", OPTIONS_REPORT_DIR: \"--report-dir\", OPTIONS_REPORTER: \"--reporter\", OPTIONS_REQUIRE: \"--require\", OPTIONS_TEMP_DIR: \"--temp-dir\", OPTIONS_TIMEOUT: \"--timeout\", OPTIONS_UI: \"--ui\", PROPERTY_COVERAGE: \"coverage\", REPORT_FORMAT_HTML: \"html\", REPORT_FORMAT_LCOV: \"lcov\", REPORT_FORMAT_TEXT: \"text\", TOARGS: \"toArgs\", TOARGSIMPL: \"toArgsImpl\", TRUE: `${ true }` }; /** * Returns default options for nyc coverage. * * @return {object} default options for nyc coverage. */ function getNYCCoverageOptions() { return { branches: false, // what % of branches must be covered? check: false, // check wether coverage is within thresholds dir: false, // report nyc coverage results to folder functions: false, // what % of functions must be covered? lines: false, // what % of lines must be covered? perfile: false, // check thresholds per file reporter: false, // report coverage using reporter 'text'|'html' statements: false // what % of statements must be covered? }; } /** * Returns default options for nyc sourcemap. * * @return {object} default options for nyc sourcemap. */ function getNYCSourcemapOptions() { return { create: undefined, // should nyc produce sourcemaps? use: undefined // should nyc detect and handle sourcemaps? }; } /** * Returns default settings for basic nyc options. * * @return {object} default settings for basic nyc options. */ function getNYCOptions() { return { all: false, clean: undefined, // clean .nyc_output folder before testing exec: false, // path to node_modules/.../nyc script excludes: false, // array of files and directories to exclude extensions: false, // additional extensions that nyc should handle includes: false, // array of files and directories to inclode opts: false, // additional options not covered by this grunt plugin requires: false, // array of scripts to additionally require temp: false, // directory to output raw coverage information }; } /** * Returns default settings for basic mocha options. * * @return {object} default settings for basic mocha options. */ function getMochaOptions() { return { bail: undefined, // abort (\"bail\") after first test failure color: false, // force colored output exec: false, // path to node_modules/.../mocha script exit: false, // force Mocha to quit after tests complete opts: false, // additional mocha options not coveredby plugin recursive: false, // look for tests in subdirectories timeout: false, // test timeout threshold (millis) ui: false // user interfaces }; } /** * Returns default settings for basic node options. * * @return {object} default settings for basic node options. */ function getNodeOptions() { return { options: false, exec: false // defaults to: process.execPath }; } /** * Defines and returns the set of options that is passed to task 'nyc_mocha'. * * @return {Object} nyc_mocha default options */ function getOptions() { return { cwd: process.cwd(), // working directory for nyc + mocha run dryrun: false, // dry run - do nothing just print cmd line }; } /** * Returns grunt task specific options for 'nyc_mocha'. * Note: 'nyc_mocha' default options and configuration options * have already been merged! * * @param {grunt.task} task * * @return {Object} 'nyc_mocha' options for grunt task */ function getTaskOptions( task ) { const taskopts = task.options(); const options = Object.assign( getOptions(), taskopts ); options.mocha = Object.assign( getMochaOptions(), /* istanbul ignore next */ taskopts.mocha || {}); options.node = Object.assign( getNodeOptions(), /* istanbul ignore next */ taskopts.node || {}); options.nyc = Object.assign( getNYCOptions(), /* istanbul ignore next */ taskopts.nyc || {}); options.nyc.coverage = Object.assign( getNYCCoverageOptions(), (( taskopts.nyc ) &amp;&amp; ( taskopts.nyc.coverage )) ? /* istanbul ignore next */ taskopts.nyc.coverage : {}); options.nyc.sourcemap = Object.assign( getNYCSourcemapOptions(), /* istanbul ignore next */ (( taskopts.nyc ) &amp;&amp; ( taskopts.nyc.sourcemap )) ? /* istanbul ignore next */ taskopts.nyc.sourcemap : {}); return options } /** * Convert grunt task specific options for 'nyc_mocha' to an array of * arguments, which will be used for calling nyc and mocha. * * @param {grunt} grunt * @param {grunt.task} task * @return {Promise&lt;Array&lt;Object&gt;&gt;} { args, opts } */ function toArgsImpl( grunt, task, options ) { return new Promise(( resolve, reject ) =&gt; { if (( grunt === null ) || ( grunt === undefined )) { return reject( new Error( _STRINGS.ERROR_MSG_MISSING_GRUNT )); } else if (( task === null ) || ( task === undefined )) { return reject( new Error( _STRINGS.ERROR_MSG_MISSING_TASK_II )); } else if (( options === null ) || ( options === undefined )) { return reject( new Error( _STRINGS.ERROR_MSG_MISSING_OPTIONS )); } try { const args = [ ]; const retval = { args, opts: options }; if ( ! options.node.exec ) { options.node.exec = process.execPath; } if ( options.node.options ) { _m.lib.isArray( grunt, options.node.options, _STRINGS.OPTIONS_NODE_OPTIONS, function( options ) { options.forEach( function( option ) { args.push( option ); }); }) } /* * NYC: Set path to nyc */ if ( ! options.nyc.exec ) { options.nyc.exec = _m.lib.getNYCPath(); } args.push( options.nyc.exec ); /* * NYC: Set current working directory --cwd */ if ( ! options.cwd ) { options.cwd = process.cwd(); } args.push( _STRINGS.OPTIONS_CWD, options.cwd ); /* * NYC: Set current working directory --cwd */ if ( options.nyc.temp ) { args.push( _STRINGS.OPTIONS_TEMP_DIR, _m.path.resolve( options.cwd, options.nyc.temp )); } /* * NYC: Set requires --require, -i */ if ( options.nyc.requires ) { _m.lib.isArray( grunt, options.nyc.requires, _STRINGS.OPTIONS_NYC_EXCLUDES, function( requires ) { requires.forEach( function ( script ) { args.push( _STRINGS.OPTIONS_REQUIRE, script ); }); }) } /* * NYC: Set excludes --exclude, -x */ if ( options.nyc.excludes ) { _m.lib.isArray( grunt, options.nyc.excludes, _STRINGS.OPTIONS_NYC_EXCLUDES, function( options ) { options.forEach( function ( exclude ) { args.push( _STRINGS.OPTIONS_EXCLUDE, exclude ); }); }) } /* * NYC: Set includes --include, -i */ if ( options.nyc.includes ) { _m.lib.isArray( grunt, options.nyc.includes, _STRINGS.OPTIONS_NYC_INCLUDES, function( options ) { options.forEach( function ( include ) { args.push( _STRINGS.OPTIONS_INCLUDE, include ); }); }) } /* * NYC: Set includes --extension, -e */ if ( options.nyc.extensions ) { _m.lib.isArray( grunt, options.nyc.extensions, _STRINGS.OPTIONS_NYC_EXTENSIONS, function( options ) { options.forEach( function ( extension ) { args.push( _STRINGS.OPTIONS_EXTENSION, extension ); }); }) } /* * NYC: Set coverage directory --report-dir */ if ( options.nyc.coverage.dir ) { args.push( _STRINGS.OPTIONS_REPORT_DIR, _m.path.resolve( options.cwd, options.nyc.coverage.dir )); } /* * NYC: Set includes --reporter, -r */ if ( options.nyc.coverage.reporter ) { _m.lib.isArray( grunt, options.nyc.coverage.reporter, _STRINGS.OPTIONS_NYC_COVERAGE_REPORTER, function( reporters ) { reporters.forEach( function ( reporter ) { args.push( _STRINGS.OPTIONS_REPORTER, reporter ); }); }) } /* * NYC: Set coverage check values */ if ( options.nyc.coverage.check ) { args.push( _STRINGS.OPTIONS_CHECK_COVERAGE, _STRINGS.TRUE ); if ( options.nyc.coverage.perfile ) { args.push( _STRINGS.OPTIONS_PER_FILE, _STRINGS.TRUE ); } if ( options.nyc.coverage.branches ) { args.push( _STRINGS.OPTIONS_BRANCHES, options.nyc.coverage.branches ); } if ( options.nyc.coverage.functions ) { args.push( _STRINGS.OPTIONS_FUNCTIONS, options.nyc.coverage.functions ); } if ( options.nyc.coverage.lines ) { args.push( _STRINGS.OPTIONS_LINES, options.nyc.coverage.lines ); } if ( options.nyc.coverage.statements ) { args.push( _STRINGS.OPTIONS_STATEMENTS, options.nyc.coverage.statements ); } } /* * NYC: Set, if nyc should clean the .nyc_output folder before running tests. * Note: defaults to undefined, to have nyc use its default settings */ if ( options.nyc.clean === true ) { args.push( _STRINGS.OPTIONS_CLEAN, _STRINGS.TRUE ); } else if ( options.nyc.clean === false ) { args.push( _STRINGS.OPTIONS_CLEAN, _STRINGS.FALSE ); } /* * NYC: Set, if nyc should produce sourcemaps --produce-source-map * Note: defaults to undefined, to have nyc use its default settings */ if ( options.nyc.sourcemap.create === true ) { args.push( _STRINGS.OPTIONS_PRODUCE_SOURCEMAP, _STRINGS.TRUE ); } else if ( options.nyc.sourcemap.create === false ) { args.push( _STRINGS.OPTIONS_PRODUCE_SOURCEMAP, _STRINGS.FALSE ); } /* * NYC: Set, if nyc should detect and handle sourcemaps --source-map * Note: defaults to undefined, to have nyc use its default settings */ if ( options.nyc.sourcemap.use === true ) { args.push( _STRINGS.OPTIONS_SOURCEMAP, _STRINGS.TRUE ); } else if ( options.nyc.sourcemap.use === false ) { args.push( _STRINGS.OPTIONS_SOURCEMAP, _STRINGS.FALSE ); } /* * NYC: Set additional options * This is an array where developers can pass nyc options which are not covered * by the grunt-nyc-mocha plugin. */ if ( options.nyc.opts ) { _m.lib.isArray( grunt, options.nyc.opts, _STRINGS.OPTIONS_NYC_OPTS, function( options ) { options.forEach( function ( option ) { args.push( option ); }); }); } /* * Append mocha and mocha options */ if ( ! options.mocha.exec ) { options.mocha.exec = _m.lib.getMochaPath(); } args.push( options.mocha.exec ); /* * mocha: bailout on first test failure --bail, -b */ if ( options.mocha.bail === true ) { args.push( _STRINGS.OPTIONS_BAILOUT, _STRINGS.TRUE ); } else if ( options.mocha.bail === false ) { args.push( _STRINGS.OPTIONS_BAILOUT, _STRINGS.FALSE ); } /* * mocha: exit force mocha to leave after completing tests --exit */ if ( options.mocha.exit === true ) { args.push( _STRINGS.OPTIONS_EXIT ); } /* * mocha: test timeout threshold (in milliseconds) --timeout */ if ( options.mocha.timeout ) { args.push( _STRINGS.OPTIONS_TIMEOUT, options.mocha.timeout ); } /* * mocha: user interface --ui */ if ( options.mocha.ui ) { args.push( _STRINGS.OPTIONS_UI, options.mocha.ui ); } /* * mocha: force colored output --color */ if ( options.mocha.color ) { args.push( _STRINGS.OPTIONS_COLOR ); } /* * mocha: look for tests in subdirectories --recursive */ if ( options.mocha.recursive ) { args.push( _STRINGS.OPTIONS_RECURSIVE ); } /* * mocha: Set additional options * This is an array where developers can pass mocha options which * are not covered by the grunt-nyc-mocha plugin. */ if ( options.mocha.opts ) { _m.lib.isArray( grunt, options.mocha.opts, _STRINGS.OPTIONS_MOCHA_OPTS, function( options ) { options.forEach( function ( option ) { args.push( option ); }); }); } /* * mocha: append test files */ retval.args = args.concat( task.filesSrc ); resolve( retval ); } catch( error ) { /* istanbul ignore next */ reject( error ); } }); } /** * Convert grunt task specific options for 'nyc_mocha' to an array of * arguments, which will be used for calling nyc and mocha. * * @param {grunt} grunt * @param {grunt.task} task * @return {Promise&lt;Array&lt;Object&gt;&gt;} { args, opts } */ function toArgs( grunt, task ) { try { if (( task === null ) || ( task === undefined )) { throw new Error( _STRINGS.ERROR_MSG_MISSING_TASK_I ); } else return toArgsImpl( grunt, task, getTaskOptions( task )); } catch( error ) { return Promise.reject( error ); } } /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.GETOPTIONS, { value: getOptions, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.GETTASKOPTIONS, { value: getTaskOptions, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.TOARGS, { value: toArgs, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.TOARGSIMPL, { value: toArgsImpl, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"tasks_nycmocha.js.html":{"id":"tasks_nycmocha.js.html","title":"Source: tasks/nycmocha.js","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Source: tasks/nycmocha.js /** * tasks/nycmocha.js: grunt-nyc-mocha * * @module grunt-nyc-mocha/tasks/nycmocha * *//* * © 2020, slashlib.org. * * tasks/nycmocha.js is distributed WITHOUT ANY WARRANTY; without even the * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * *//* eslint-disable-next-line */ \"use strict\"; /** * Module initializer * @ignore */ const _m = { nycmochaopts: require( \"../options/nycmocha\" ) }; /** * Stringtable initializer * @ignore */ function _init_STRINGS() { const executenycmocha = \"executeNYCMocha\"; const missingproperty = \"Missing property\"; return { ERROR_MSG_MISSING_ARGS: `${ executenycmocha }: ${ missingproperty } 'obj.args'.`, ERROR_MSG_MISSING_OPTS: `${ executenycmocha }: ${ missingproperty } 'obj.opts'.`, ERROR_MSG_MISSING_CWD: `${ executenycmocha }: ${ missingproperty } 'options.cwd'.`, ERROR_MSG_MISSING_NODEEXEC: `${ executenycmocha }: ${ missingproperty } 'options.node.exec'.`, EXECUTENYCMOCHA: `${ executenycmocha }`, IGNORE: \"ignore\", INHERIT: \"inherit\", RUNTASKNYCMOCHA: \"runTaskNYCMocha\" }; } /** * Stringtable * @ignore */ const _STRINGS = _init_STRINGS(); /** * Return a promise for executing * 'node --[node opts] nyc --[nyc opts] mocha --[mocha opts]' * * @param {grunt} grunt the runtime 'instance' of grunt. * @param {grunt.task} task the current task * @param {Object} obj wrapper for options and arguments. */ function executeNYCMocha( grunt, task, obj ) { return new Promise(( resolve, reject ) =&gt; { try { let args = undefined; if (( ! obj ) || ( ! obj.args )) { throw new Error( _STRINGS.ERROR_MSG_MISSING_ARGS ); } else args = obj.args; let options = undefined; if (( ! obj ) || ( ! obj.opts )) { throw new Error( _STRINGS.ERROR_MSG_MISSING_OPTS ); } else options = obj.opts; const env = process.env; let cwd = undefined; if ( ! options.cwd ) { throw new Error( _STRINGS.ERROR_MSG_MISSING_CWD ); } else cwd = options.cwd; let stdio = options.quiet ? _STRINGS.IGNORE : _STRINGS.INHERIT; const opts = { env, cwd, stdio }; let cmd = undefined; if ( ! options.node.exec ) { throw new Error( _STRINGS.ERROR_MSG_MISSING_NODEEXEC ); } else cmd = options.node.exec; const logmsg = `Will execute (stdio: '${ stdio }'): ${ cmd } ${ args.join( \" \" )}`; /* istanbul ignore else */ if ( options.dryrun ) { grunt.log.ok( logmsg ); return resolve( obj ); } else grunt.verbose.ok( logmsg ); /* istanbul ignore next */ grunt.util.spawn({ cmd, args, opts }, ( error, result ) =&gt; { if ( ! error ) { obj.result = result; resolve( obj ); } else reject( error ); }); } catch( error ) { reject( error ); } }); } /** * Run the nyc mocha task. * * @return {Promise} ... required by callee to terminate async call (on \"then\") */ function runTaskNYCMocha( grunt, task ) { let promise = _m.nycmochaopts.toArgs( grunt, task ); // prepare args for test runs ... promise = promise.then(( obj ) =&gt; { // run the tests... return executeNYCMocha( grunt, task, obj ); }); return promise; } /* eslint-disable */ // Module exports: Object.defineProperty( module.exports, _STRINGS.EXECUTENYCMOCHA, { value: executeNYCMocha, writable: false, enumerable: true, configurable: false }); Object.defineProperty( module.exports, _STRINGS.RUNTASKNYCMOCHA, { value: runTaskNYCMocha, writable: false, enumerable: true, configurable: false }); /* eslint-enable */ × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Modules × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"index.html":{"id":"index.html","title":"Index","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha grunt-nyc-mocha grunt task for running tests and coverage, based on nyc and mocha. content Usage Getting started guide (see 'getting started' below) Reference of all available options Sourcemap support Developers Testing grunt-nyc-mocha Code coverage of tests for grunt-nyc-mocha Build grunt-nyc-mocha from scratch Frameworks used for building and running grunt-nyc-mocha API of package grunt-nyc-mocha getting started This guide assumes, that you are familiar with the use of npm and grunt. The plugin can be installed by the following command: npm install grunt-nyc-mocha --save-dev Once installed, the plugin may be loaded from within your gruntfile. task nyc_mocha \"nyc_mocha\" is a grunt multitask provided by grunt-nyc-mocha and can hold multiple targets. Each of the targets you may define will spawn their very own node process. Multitask configuration generally splits into the following parts: options (tasklevel, inherited by any target) target (0 to n) any other grunt configuration properties options (targetlevel, will be merged into tasklevel options) Any target can extend, repeat or overwrite options previously defined by a task. For doing so, each target can specify its own \"options\" property. Targetlevel options will be merged into tasklevel options, overwriting them. raw usage of grunt-nyc-mocha // extract from gruntfile.js module.exports = function( grunt ) { grunt.initConfig({ // among many others ... nyc_mocha:{ options: { /*tasklevel options go here*/ } target: { src: \"./src/test/**/*.spec.js\", // test suites to run... options: { /* targetlevel options go here */ } } } }); grunt.loadNpmTasks( \"nyc_mocha\" ); grunt.registerTask( \"default\", [ \"nyc_mocha:target\" ]); } using grunt-nyc-mocha with load-grunt-config and load-grunt-tasks Install the following packages: npm install load-grunt-config --save-dev npm install load-grunt-tasks --save-dev Now you can split gruntfile.js in multiple configuration files: // extract from (a much cleaner) gruntfile.js const configPath = ...? // this is where your config files reside const data = { /* some properties, that can be passed on */ }; module.exports = function( grunt ) { require( \"load-grunt-config\" )( grunt, { configPath, data }); require( \"load-grunt-tasks\" )( grunt ); grunt.registerTask( \"default\", [ \"nyc_mocha:target\" ]); } // extract from nyc_mocha.js (has to be named tasklike!) module.exports = function ( grunt, options ) { return { target: { src: \"./src/test/**/*.spec.js\", // run those test files options: { nyc: { coverage: { // report nyc coverage results dir: \"dist/coverage\", // ... to folder reporter: [ \"html\", \"text-summary\" ] // ... using reporters }, excludes: [ \"**/*.spec.js\" ], // exclude test files from instrumentation! requires: [ \"grunt-nyc-mocha/scripts/sourcemapsupport\" ] }, mocha: { color: true // force colored output } } } } }; × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha.html":{"id":"module-grunt-nyc-mocha.html","title":"Module: grunt-nyc-mocha","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha index.js: grunt-nyc-mocha Source: index.js, line 1 Methods &lt;inner&gt; registerMultiTaskNYCMocha(grunt) Registers the 'nyc_mocha' multitask. Parameters: Name Type Description grunt grunt Source: index.js, line 37 Module: grunt-nyc-mocha index.js: grunt-nyc-mocha Source: tasks/index.js, line 2 Methods &lt;inner&gt; registerMultiTaskNYCMocha(grunt) Registers the 'nyc_mocha' multitask. Parameters: Name Type Description grunt grunt Source: index.js, line 37 × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha_constants.html":{"id":"module-grunt-nyc-mocha_constants.html","title":"Module: grunt-nyc-mocha/constants","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha/constants constants.js: grunt-nyc-mocha Source: constants.js, line 2 × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha_lib.html":{"id":"module-grunt-nyc-mocha_lib.html","title":"Module: grunt-nyc-mocha/lib","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha/lib lib.js: grunt-nyc-mocha Source: lib.js, line 1 Methods &lt;inner&gt; getMochaPath(grunt) Returns the path to the mocha executable/startscript Parameters: Name Type Description grunt grunt Source: lib.js, line 40 Returns: path to mocha Type string &lt;inner&gt; getNYCPath(grunt) Returns the path to the nyc executable/startscript Parameters: Name Type Description grunt grunt Source: lib.js, line 51 Returns: path to nyc Type string &lt;inner&gt; isArray(grunt, options, name, callback) Checks if options is of type array and passes it to callback. Parameters: Name Type Description grunt grunt options Array name string callback function Source: lib.js, line 64 × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha_options.html":{"id":"module-grunt-nyc-mocha_options.html","title":"Module: grunt-nyc-mocha/options","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha/options index.js: grunt-nyc-mocha/options Source: options/index.js, line 2 Methods &lt;inner&gt; toNYCMochaArgs() Returns an object wich holds an array of arguments, which will be used to run the 'nyc_mocha' task and the array of options the arguments were created from. Source: options/index.js, line 41 Returns: obj Type Promise.&lt;Object&gt; obj.args an array of arguments Type Array.&lt;strings&gt; obj.opts an array of options Type Array.&lt;any&gt; × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha_options_nycmocha.html":{"id":"module-grunt-nyc-mocha_options_nycmocha.html","title":"Module: grunt-nyc-mocha/options/nycmocha","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha/options/nycmocha options/nycmocha.js: grunt-nyc-mocha Source: options/nycmocha.js, line 1 Methods &lt;inner&gt; getMochaOptions() Returns default settings for basic mocha options. Source: options/nycmocha.js, line 129 Returns: default settings for basic mocha options. Type object &lt;inner&gt; getNodeOptions() Returns default settings for basic node options. Source: options/nycmocha.js, line 147 Returns: default settings for basic node options. Type object &lt;inner&gt; getNYCCoverageOptions() Returns default options for nyc coverage. Source: options/nycmocha.js, line 80 Returns: default options for nyc coverage. Type object &lt;inner&gt; getNYCOptions() Returns default settings for basic nyc options. Source: options/nycmocha.js, line 110 Returns: default settings for basic nyc options. Type object &lt;inner&gt; getNYCSourcemapOptions() Returns default options for nyc sourcemap. Source: options/nycmocha.js, line 98 Returns: default options for nyc sourcemap. Type object &lt;inner&gt; getOptions() Defines and returns the set of options that is passed to task 'nyc_mocha'. Source: options/nycmocha.js, line 159 Returns: nyc_mocha default options Type Object &lt;inner&gt; getTaskOptions(task) Returns grunt task specific options for 'nyc_mocha'. Note: 'nyc_mocha' default options and configuration options have already been merged! Parameters: Name Type Description task grunt.task Source: options/nycmocha.js, line 175 Returns: 'nyc_mocha' options for grunt task Type Object &lt;inner&gt; toArgs(grunt, task) Convert grunt task specific options for 'nyc_mocha' to an array of arguments, which will be used for calling nyc and mocha. Parameters: Name Type Description grunt grunt task grunt.task Source: options/nycmocha.js, line 459 Returns: { args, opts } Type Promise.&lt;Array.&lt;Object&gt;&gt; &lt;inner&gt; toArgsImpl(grunt, task) Convert grunt task specific options for 'nyc_mocha' to an array of arguments, which will be used for calling nyc and mocha. Parameters: Name Type Description grunt grunt task grunt.task Source: options/nycmocha.js, line 198 Returns: { args, opts } Type Promise.&lt;Array.&lt;Object&gt;&gt; × Search results Close api docs grunt-nyc-mocha version 0.0.6 "},"module-grunt-nyc-mocha_tasks_nycmocha.html":{"id":"module-grunt-nyc-mocha_tasks_nycmocha.html","title":"Module: grunt-nyc-mocha/tasks/nycmocha","body":" grunt-nyc-mocha Modules grunt-nyc-mochagrunt-nyc-mocha/constantsgrunt-nyc-mocha/libgrunt-nyc-mocha/optionsgrunt-nyc-mocha/options/nycmochagrunt-nyc-mocha/tasks/nycmocha Module: grunt-nyc-mocha/tasks/nycmocha tasks/nycmocha.js: grunt-nyc-mocha Source: tasks/nycmocha.js, line 1 Methods &lt;inner&gt; executeNYCMocha(grunt, task, obj) Return a promise for executing 'node --[node opts] nyc --[nyc opts] mocha --[mocha opts]' Parameters: Name Type Description grunt grunt the runtime 'instance' of grunt. task grunt.task the current task obj Object wrapper for options and arguments. Source: tasks/nycmocha.js, line 57 &lt;inner&gt; runTaskNYCMocha() Run the nyc mocha task. Source: tasks/nycmocha.js, line 115 Returns: ... required by callee to terminate async call (on \"then\") Type Promise × Search results Close api docs grunt-nyc-mocha version 0.0.6 "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
